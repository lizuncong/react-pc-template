file-loader将import或require引用的文件解析成url，
并将文件输出到output目录下

url-loader
一个将文件转成base64格式的loader
和file-loader类似，只不过当文件大小小于
指定的limit时，url-loader能够将文件转成base64格式
limit默认为undefined。单位为byte。

建议使用url-loader，当图片小于指定的limit时，可以将图片转为base64格式，减少http请求
提高图片加载速度，这个在小图标的使用上优势更明显。

打包成base64的好处就是减少http请求，弊端就是增加打包后的bundle体积。因此小图打包成base64，
大图还是用file-loader处理，以文件的形式打包。

解析.css文件，使用css-loader及style-loader
css-loader会分析css文件之间的关联关系，然后合成一段css
比如这里，在index.js入口文件引入index.css
1.index.css内容：
@import "./cat.css";
.img{
    width: 200px;
    height: 200px;
    background-color: green;
}

2.cat.css内容：
.cat{
    width: 200px;
    height: 200px;
}
.img{
    background-color: red;
}

经过css-loader，style-loader处理好以后，可以在控制台看到如下输出:


css-loader配置项importLoaders的说明：
如果我们在js文件中通过import './xxx.scss'的方式引用scss，那么所引用scss文件一定会
依次经过sass-loader -> postcss-loader -> css-loader -> style-loader处理

如果我们在.scss文件中通过@import引用.scss文件，比如在index.scss文件中@import './test.scss'文件，
那么这个test.scss文件有可能直接经过css-loader处理，而不会经过sass-loader，postcss-loader处理，
这是css-loader的@import规则决定的。因此为了确保scss文件里面引用的scss文件能够起作用，需要
配置importLoaders参数


sourceMap:
开发环境下，devtool的最佳实践是使用cheap-module-eval-source-map
提示的错误信息比较全，打包速度比较快 
devtool: "cheap-module-eval-source-map"

在生产环境下，devtool的最佳实践是使用cheap-module-source-map


inline前缀，即souceMap文件会以base64的形式打包进bundle文件中，
cheap前缀，只对业务代码，不对第三方依赖做souceMap。并且错误信息只提示到行，不会精确提示到哪一列
module前缀，不仅对业务代码，也对第三方依赖做souceMap。

Tree Shaking只支持es module
package.json 里面的sideEffects字段设置为false，表示告诉webpack所有文件都运用tree shaking打包，
去掉那些没用的代码。
但是如果我们确实是有文件有用处，比如如果我们在index.js入口文件处
引用import '@babel/polyfill'，这个文件没有导出，但是会改变全局的变量，比如
Promise，这个确实是需要用到的，这个时候我们可以设置
sideEffects: ["@babel/polyfill"]告诉webpack打包的时候忽略这个文件的tree shaking。
对于css文件的引入，比如import './style.css'，如果设置sideEffects为false，那么webpack
打包遇到这个文件，也会运用tree shaking把它删掉，显然不符合我们的期望，
因此需要设置sideEffects:["*.css"]忽略css文件的tree shaking。
tree shaking在开发模式下并不会将没用的代码删掉，还会打包进bundle中，这是因为开发模式下，需要一些调试信息，
如果删掉代码，那么source map行数这些信息将会不一致。
因此在生产模式下才会删掉无用代码。
事实上，如果在生产环境下(可能开发环境也是一样，可以验证一下)，tree shaking也不一定会删掉无用代码的，这与source map的设置也有关系
如果设置source map:cheap-module-source-map，那么tree shaking就会删掉无用代码


  // mode: 'development',
  // 开发环境下，devtool的最佳实践是使用cheap-module-eval-source-map,
  // 提示的错误信息比较全，打包速度比较快
  // devtool: "cheap-module-source-map", // production模式下最佳实践
  // devtool: "cheap-module-eval-source-map", // 开发模式下最佳实践
  // development默认开启sourceMap
  // 前面加个inline，souceMap文件会被打包成base64字符串，在打包后的bundle中引用。
  // devtool: "inline-source-map",
  // 如果不加cheap，那么报错信息会精确提示到某个文件某一行某一列，这个通常很耗费性能。
  // 所以如果用cheap，那么报错信息只会提示到某个文件某一行。
  // cheap还有一个好处，cheap只会映射业务代码，不会对node_module下面的代码等第三方模块做映射.
  // devtool: "cheap-inline-source-map",
  // 如果需要对第三方依赖也做映射，可以使用cheap-module
  // devtool: "cheap-module-inline-source-map",
  // devtool: "eval",
  // 这个配置，sourceMap文件会被打包成单独的文件，输出到打包后的目录中
  // devtool: "source-map",


        // options: {
          // @babel/preset-env及@babel/plugin-transform-runtime只需要配置其中一项就可以了。
          // 如果我们是写业务代码而不是组件库，那么使用@babel/preset-env就可以了，这种polyfill方式会污染全局的变量，
          // 比如会污染Promise，Set等。
          // 如果我们开发的是给其他人安装使用的组件库，那么使用@babel/plugin-transform-runtime就可以了。这种方式不会
          // 污染全局变量。详细说明见babel官网
          // presets: [["@babel/preset-env", {
          //   // 如果不加这个配置项，那么@babel/polyfill会将所有的es6新特性代码都打包进
          //   // bundle中，但是如果我们的业务代码中只用到promise这个新特性，然后@babel/polyfill
          //   // 不仅将promise，还将class，set等这些我们业务代码中没用到的特性打包进去，会造成
          //   // 包体积过大。我们只希望打包我们用到的新特性，比如只打包promise。
          //   useBuiltIns: "usage",
          //   corejs: 3
          // }]]
          // plugins: [["@babel/plugin-transform-runtime", {
          //   corejs: 3,
          // }]],
        // }
      {
        test: /\.scss$/,
        use: [
          {
            // Creates `style` nodes from JS strings
            loader: 'style-loader',
          },
          {
            // Translates CSS into CommonJS
            loader: 'css-loader',
            options: {
              // 确保每一个通过@import引用的scss文件都经过前面两个loader的处理
              importLoaders: 2,
              // css sourceMap打开后，在控制台检查元素的时候在样式旁边可以
              // 看到该样式在哪个文件
              sourceMap: false, // default is false
              // 开启css模块化打包，开启模块化打包后，必须通过import xxx from './xxx.scss'的形式引入而不能
              // 简单的通过import './xxx.scss'方式引入
              modules: {
                mode: 'local',
                // use '[path][name]__[local]' for development
                // use '[hash:base64]' for production
                localIdentName: '[path][name]__[local]--[hash:base64:5]',
              },
            }
          },
          {
            loader: 'postcss-loader',
          },
          {
            // compiles Sass to CSS
            loader: 'sass-loader'
          }
        ]
      },

webpackPrefetch: true 预请求
document.addEventListener('click', () => {
  import(/* webpackPrefetch: true */'./click.js').then(({ default: func }) => {
    func()
  })
})
异步加载能够显著提升性能，同步加载模块对性能的提升不明显。这也是为啥webpack默认的splitChunks的chunks属性默认
值为"async"

使用webpackPrefetch优于使用webpackPreload


模块里的this并不指向window。可以新建一个文件，如index.js。
在index.js里直接console.log( this === window)。会发现输出false。
可见模块里的this并不指向window。如果需要模块里的this强制指向window。
可以使用imports-loader强制把this指向window


pwa:服务断开或者网络断开的时候也能访问网站的技术。借助workbox-webpack-plugin插件可以
很容易配置pwa。只有生产环境才需要pwa



提升webpack打包速度的方法。
1.跟上技术的迭代，及时更新各种版本，比如node，npm，yarn，webpack等。
2.在尽可能少的模块上应用Loader
3.plugin尽可能少
